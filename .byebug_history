continue
private_key
r_func(rand_val).class
r_func(rand_val)
continue
s_func(rand_val, private_key)
continue
r_func(rand_val)
rand_val
continue
rand(1..@elliptic_curve.opts[:n])
exit
@elliptic_curve.opts
exit
continue
ModularArithmetic.invert(new_x, @opts[:p])
 ModularArithmetic.invert(3, 26)
ModularArithmetic.invert(new_x, @opts[:p])
@opts[:p]
new_x
ModularArithmetic.invert(new_x, @opts[:p])
exit
EllipticCurvePoint.new(@elliptic_curve.opts, @elliptic_curve.base_point) * rand_val
continue
other / 2
double
(other % 2)
(other % 2).odd?
continue
(other % 2).odd?
other
other % 2
self
other
exit
continue
new_y
new_x
continue
ModularArithmetic.invert(new_x, @opts[:p])
new_y
new_x
continue
new_y
continue
(2 * y)
2 * y
add_ec_module(2 * y)
y
new_y
continue
@elliptic_curve.base_point
rand_val
